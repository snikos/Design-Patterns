{
"woodoo": [
{
	"id": 0,
	"title":"Хранитель",
	"type":"поведенческий",
	"wiki":"Хранитель_(шаблон_проектирования)",
	"whatitis":"Не нарушая инкапсуляцию, определяет и сохраняет внутреннее состояние объекта и позволяет восстановить объект в этом состоянии позже."
},{
	"id": 1,
	"title":"Цепочка обязанностей",
	"type":"поведенческий",
	"wiki":"Цепочка_обязанностей",
	"whatitis":"Избегает связывания отправителя запроса с его получателем, давая возможность обработать запрос более чем одному объекту. Связывает объекты-получатели и передает запрос по цепочке пока объект не обработает его."
},{
	"id": 2,
	"title":"Наблюдатель",
	"type":"Поведенческий",
	"wiki":"Наблюдатель_(шаблон_проектирования)",
	"whatitis":"Определяет зависимость ОДИН ко МНОГИМ между объектами так, что когда один объект меняет свое состояние, все зависимые объекты оповещаются и обновляются автоматически."
},{
	"id": 3,
	"title":"Команда",
	"type":"Поведенческий",
	"wiki":"Команда_(шаблон_проектирования)",
	"whatitis":"Инкапсулирует запрос в виде объекта, позволяя передавать их клиентам в качестве параметров, ставить в очередь, логировать, я также поддерживает отмену операций."
},{
	"id": 4,
	"title":"Состояние",
	"type":"поведенческий",
	"wiki":"Состояние_(шаблон_проектирования)",
	"whatitis":"Позволяет объекту изменять свое поведение в зависимости от внутреннего состояния."
},{
	"id": 5,
	"title":"Интерпетатор",
	"type":"Поведенческий",
	"wiki":"Интерпретатор_(шаблон_проектирования)",
	"whatitis":"Получая формальный язык, определяет представление его грамматики и интерпретатор, использующий это представление для обработки выражений языка."
},{
	"id": 6,
	"title":"Стратегия",
	"type":"Поведенческий",
	"wiki":"Стратегия_(шаблон_проектирования)",
	"whatitis":"Определяет группу алгоритмов, инкапсулиует их и делает взаимозаменяемыми. Позволяет изменять алгоритм независимо от клиентов, его использующих."
},{
	"id": 7,
	"title":"Итератор",
	"type":"Поведенческий",
	"wiki":"Итератор_(шаблон_проектирования)",
	"whatitis":"Педоставляет способ последовательного доступа к элементам множества, независимо от его внутеннего устойства."
},{
	"id": 8,
	"title":"Шаблонный метод",
	"type":"Поведенческий",
	"wiki":"Шаблонный_метод_(шаблон_проектирования)",
	"whatitis":"Определяет алгоритм, некоторые этапы которого делегируются подклассами. Позволяет подклассам переопределить эти этапы, не меняя структуру алгоритма."
},{
	"id": 9,
	"title":"Посредник",
	"type":"Поведенческий",
	"wiki":"Посредник_(шаблон_проектирования)",
	"whatitis":"Определяет объект, инкапсулирующий способ взаимодействия объектов. Обеспечивает слабую связь, избавляя объекты от необходимости прямо ссылаться друг на друга и дает возможность изменять их взаимодействие."
},{
	"id": 10,
	"title":"Посетитель",
	"type":"Поведенческий",
	"wiki":"Посетитель_(шаблон_проектирования)",
	"whatitis":"Представляет собой операцию, которая будет выполнена над объектами группы классов. Дает возможность определить новую операцию без изменения кода классов, над которыми эта операция проводится."
},{
	"id": 11,
	"title":"Адаптер",
	"type":"Структурный",
	"wiki":"Адаптер_(шаблон_проектирования)",
	"whatitis":"Конвертирует интерфейс класса в другой интерфейс, ожидаемый клиентом. Позволяет классам с разными интерфейсами работать вместе."
},{
	"id": 12,
	"title":"Заместитель",
	"type":"Структурный",
	"wiki":"Заместитель_(шаблон_проектирования)",
	"whatitis":"Предоставляет замену другого объекта для контроля доступа к нему."
},{
	"id": 13,
	"title":"Мост",
	"type":"Структурный",
	"wiki":"Мост_(шаблон_проектирования)",
	"whatitis":"Разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо."
},{
	"id": 14,
	"title":"Абстрактная фабрика",
	"type":"Порождающий",
	"wiki":"Абстрактная_фабрика_(шаблон_проектирования)",
	"whatitis":"Предоставляет интерфейс для создания групп связанных объектов, не указывая их конкретный класс."
},{
	"id": 15,
	"title":"Компоновщик",
	"type":"Структурный",
	"wiki":"Компоновщик_(шаблон_проектирования)",
	"whatitis":"Компонует объекты в древовидную структуру, представляя их в виде иерархии. Позволяет клиенту одинаково обращаться как к отдельному объекту, так и к целому поддереву."
},{
	"id": 16,
	"title":"Строитель",
	"type":"Порождающий",
	"wiki":"Строитель_(шаблон_проектирования)",
	"whatitis":"Разделяет создание сложного объекта и инициализацию его состояния так, что одинаковый процесс построения может создать объект с разным состоянием."
},{
	"id": 17,
	"title":"Декоратор",
	"type":"Структурный",
	"wiki":"Декоратор_(шаблон_проектирования)",
	"whatitis":"Динамически предоставляет объекту дополнительные возможности. Представляет собой гибкую альтернативу наследованию для расширения функциональности."
},{
	"id": 18,
	"title":"Фабричный метод",
	"type":"Порождающий",
	"wiki":"Фабричный_метод_(шаблон_проектирования)",
	"whatitis":"Определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать. Позволяет делегировать создание объекта подклассам."
},{
	"id": 19,
	"title":"Фасад",
	"type":"Структурный",
	"wiki":"Фасад_(шаблон_проектирования)",
	"whatitis":"Педоставляет единый интерфейс к группе интерфейсов подсистемы. Определяет высокоуровневый интерфейс, делая подсистему проще для использования."
},{
	"id": 20,
	"title":"Прототип",
	"type":"Порождающий",
	"wiki":"Прототип_(шаблон_проектирования)",
	"whatitis":"Определяет несколько видов объектов, чтобы при создании использовать объект-прототип и создает новые объекты, копируя прототип."
},{
	"id": 21,
	"title":"Приспособленец",
	"type":"Структурный",
	"wiki":"Приспособленец_(шаблон_проектирования)",
	"whatitis":"Благодаря совместному использованию, поддерживает эффективную работу с большим колличеством объектов."
},{
	"id": 22,
	"title":"Одиночка",
	"type":"Порождающий",
	"wiki":"Одиночка_(шаблон_проектирования)",
	"whatitis":"Гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему."
}
],
"kindof":[
	{
		"порождающий": "Порождающие шаблоны проектирования. Шаблоны проектирования, которые имеют дело с процессом создания объектов. Они позволяют сделать систему независимой от способа создания, композиции и представления объектов. Шаблон, порождающий классы, использует наследование, чтобы изменять наследуемый класс, а шаблон, порождающий объекты, делегирует инстанцирование другому объекту. Эти шаблоны оказываются важны, когда система больше зависит от композиции объектов, чем от наследования классов. Получается так, что основной упор делается не на жестком кодировании фиксированного набора поведений, а на определении небольшого набора фундаментальных поведений, с помощью композиции которых можно получать любое число более сложных. Таким образом, для создания объектов с конкретным поведением требуется нечто большее, чем простое инстанцирование класса. Порождающие шаблоны инкапсулируют знания о конкретных классах, которые применяются в системе, то есть скрывают детали того, как эти классы создаются и стыкуются. Единственная информация об объектах, известная системе, — это их интерфейсы, определенные с помощью абстрактных классов. Следовательно, порождающие шаблоны обеспечивают большую гибкость при решении вопроса о том, что создается, кто это создает, как и когда. Можно собрать систему из «готовых» объектов с самой различной структурой и функциональностью статически (на этапе компиляции) или динамически (во время выполнения). Иногда допустимо выбирать между тем или иным порождающим шаблоном. Например, есть случаи, когда с пользой для дела можно использовать как прототип, так и абстрактную фабрику. В других ситуациях порождающие шаблоны дополняют друг друга. Так, применяя строитель, можно использовать другие шаблоны для решения вопроса о том, какие компоненты нужно строить, а прототип часто реализуется вместе с одиночкой. Порождающие шаблоны тесно связаны друг с другом, их рассмотрение лучше проводить совместно, чтобы лучше были видны их сходства и различия."
	},{
		"структурный": "Структурные шаблоны проектирования. Шаблоны проектирования, в которых рассматривается вопрос о том, как из классов и объектов образуются более крупные структуры. Структурные шаблоны уровня класса используют наследование для составления композиций из интерфейсов и реализаций. Простой пример — использование множественного наследования для объединения нескольких классов в один. В результате получается класс, обладающий свойствами всех своих родителей. Особенно полезен этот шаблон, когда нужно организовать совместную работу нескольких независимо разработанных библиотек."
	},{
		"поведенческий": "Поведенческие шаблоны проектирования. Шаблоны проектирования, определяющие алгоритмы и способы реализации взаимодействия различных объектов и классов. В поведенческих шаблонах уровня класса используется наследование, чтобы определить поведение для различных классов. В поведенческих шаблонах уровня объекта используется композиция. Некоторые из них описывают, как с помощью кооперации несколько равноправных объектов работают над заданием, которое они не могут выполнить по отдельности. Здесь важно то, как объекты получают информацию о существовании друг друга. Объекты-коллеги могут хранить ссылки друг на друга, но это усиливает степень связанности системы. При высокой связанности каждому объекту пришлось бы иметь информацию обо всех остальных. Некоторые из шаблонов решают эту проблему."
	}
]}